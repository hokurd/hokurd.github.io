<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="北陸地区の道路をまとめたページです。">
  <meta name="robots" content="index, follow">

  <meta property="og:title" content="ほくりく道路図鑑">
  <meta property="og:type" content="website">
  <meta property="og:site_name" content="ほくりく道路図鑑">
  <meta property="og:locale" content="ja_JP">

  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="ほくりく道路図鑑">
  <meta name="twitter:description" content="北陸地区の道路をまとめたページです。">

  <title>ほくりく道路図鑑 | 現在地から探す</title>
  <link rel="stylesheet" href="https://hokurd.github.io/assets/css/common.css">
  <link rel="icon" href="https://hokurd.github.io/assets/img/rd/country/41.png">

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" defer></script>
</head>
<body>
  <header>
    <h1><a href="https://hokurd.github.io/" style="color: white;"><img src="https://hokurd.github.io/assets/img/rd/country/41.png" alt="管理団体画像" style="height:48px; width:auto;"> ほくりく道路図鑑</a></h1>
  </header>

  <div class="container">
    <aside id="menu"></aside>

    <main id="content">
      <section>
        <h2>現在地から探す</h2>
        <p>現在地から探します。</p>
        <p>地図や情報の取得には時間がかかります。</p>
        <p>この機能はテスト段階です。</p>
        <p>しばらくしても表示されない場合、ページを再読み込みしてください。</p>
      </section>
      <div class="spacer"></div>
      <section>
        <h2>現在地</h2>
        <div id="map" style="width:100%; height:400px;" role="application" aria-label="現在地の地図"></div>
      </section>
      <div class="spacer"></div>
      <section>
        <h2>現在走行している道路</h2>
        <div id="current-road"></div>
        <div id="map-current-road" class="small-map" aria-hidden="false"></div>
      </section>
      <div class="spacer"></div>
      <section>
        <h2>次の交差点</h2>
        <div id="next-intersection"></div>
        <div id="map-next-intersection" class="small-map"></div>
      </section>
      <div class="spacer"></div>
      <section>
        <h2>最も近い高速道路</h2>
        <div id="nearest-motorway"></div>
        <div id="map-motorway" class="small-map"></div>
      </section>
      <div class="spacer"></div>
      <section>
        <h2>最も近い国道</h2>
        <div id="nearest-trunk"></div>
        <div id="map-trunk" class="small-map"></div>
      </section>
      <div class="spacer"></div>
      <section>
        <h2>最も近い県道</h2>
        <div id="nearest-pref"></div>
        <div id="map-pref" class="small-map"></div>
      </section>
    </main>
  </div>

  <footer>
    <p>Copyright © いゆかも工房 All rights reserved.</p>
  </footer>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      function escapeHtml(s){ return String(s || '').replace(/[&<>"]/g, c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c])); }
      const NOMINATIM_EMAIL = '';
      const PREF_BG = {
        '富山県': 'toyama',
        '新潟県': 'niigata',
        '石川県': 'ishikawa',
        '福井県': 'fukui'
      };
      let mainMap = null;
      let motorwayMap = null;
      let currentRoadMap = null;
      let nextIntersectionMap = null;
      let trunkMap = null;
      let prefMap = null;
      let lastPos = null;
      let prevPos = null;
      let lastHeading = null;
      let lastUpdateCall = 0;
      let scheduledUpdateTimer = null;
      let overpassInFlight = false;
      const MIN_UPDATE_INTERVAL_MS = 10000;
      const MIN_MOVE_DISTANCE_M = 20;
      function sanitizeFileKey(k){
        if(!k) return 'unknown';
        const s = String(k).toLowerCase().replace(/県$/,'').replace(/[^a-z0-9_-]/g,'');
        return s || 'unknown';
      }
      function pickRefToken(ref){
        if(!ref) return '';
        const parts = ref.split(/[\s;,\/]+/);
        for(const p of parts) if(/^E\d+/i.test(p)) return p;
        for(const p of parts) if(/^[Pp]\d+/.test(p)) return p;
        for(const p of parts) if(/^\d+$/.test(p)) return p;
        return parts[0] || '';
      }
      function distanceMeters(lat1, lon1, lat2, lon2){
        const R = 6371e3;
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const Δφ = (lat2 - lat1) * Math.PI/180;
        const Δλ = (lon2 - lon1) * Math.PI/180;
        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      }
      function distanceMetersSimple(aLat, aLon, bLat, bLon){
        const R = 6371e3;
        const φ1 = aLat * Math.PI/180;
        const φ2 = bLat * Math.PI/180;
        const Δφ = (bLat - aLat) * Math.PI/180;
        const Δλ = (bLon - aLon) * Math.PI/180;
        const a = Math.sin(Δφ/2) * Math.sin(Δφ/2) + Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ/2) * Math.sin(Δλ/2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      }
      function bearingBetween(lat1, lon1, lat2, lon2){
        const φ1 = lat1 * Math.PI/180;
        const φ2 = lat2 * Math.PI/180;
        const λ1 = lon1 * Math.PI/180;
        const λ2 = lon2 * Math.PI/180;
        const y = Math.sin(λ2-λ1) * Math.cos(φ2);
        const x = Math.cos(φ1)*Math.sin(φ2) - Math.sin(φ1)*Math.cos(φ2)*Math.cos(λ2-λ1);
        let θ = Math.atan2(y, x) * 180 / Math.PI;
        θ = (θ + 360) % 360;
        return θ;
      }
      function angleDiff(a, b){
        let d = Math.abs(a - b) % 360;
        if (d > 180) d = 360 - d;
        return d;
      }
      function isMotorwayWay(tags){
        if(!tags) return false;
        if(tags.highway === 'motorway') return true;
        if(/^E\d+/i.test(tags.ref || '')) return true;
        if(/expressway|motorway/i.test(tags.network || '') || /expressway/i.test(tags.operator || '')) return true;
        return false;
      }
      function isPrefectureWay(tags){
        if(!tags) return false;
        if(/pref/i.test(tags.network || '')) return true;
        if(/県道/.test(tags.name || '')) return true;
        if(/^[Pp]\d+/.test(tags.ref || '')) return true;
        if((tags.operator || '').match(/(県|府|都)$/)) return true;
        return false;
      }
      function isNationalWay(tags){
        if(!tags) return false;
        if(isPrefectureWay(tags)) return false;
        if(tags.highway === 'trunk') return true;
        const r = pickRefToken(tags.ref || '');
        if(/^\d+$/.test(r)) return true;
        if(/national|jp:road|jp:r/i.test(tags.network || '')) return true;
        return false;
      }
      function shortRoadLabel(tags){
        if(!tags) return '不明な道路';
        if(tags.name) return tags.name;
        const r = pickRefToken(tags.ref || '');
        if(isMotorwayWay(tags)) return (r ? r + ' ' : '') + (tags.name || '高速道路');
        if(isNationalWay(tags)) return (r ? '国道' + r + '号' : '国道');
        if(isPrefectureWay(tags)) return (r ? '県道' + r : '県道');
        return tags.ref || tags.highway || '道路';
      }
      function makeRoadAnchorElement(tags, linkify){
        linkify = !!linkify;
        const refToken = pickRefToken(tags && tags.ref ? tags.ref : '');
        const name = tags && tags.name ? tags.name : '';
        const isMotorway = isMotorwayWay(tags);
        const isPref = isPrefectureWay(tags);
        const isNat = isNationalWay(tags);
        const createSpan = (innerText) => {
          const span = document.createElement('span');
          span.className = 'contact-button';
          span.textContent = innerText;
          return span;
        };
        if(isMotorway){
          const code = refToken || (tags.operator || '').replace(/\s+/g,'') || 'E?';
          const display = (code + (name ? (' ' + name) : ''));
          if(linkify){
            const a = document.createElement('a');
            a.className = 'contact-button';
            a.href = `https://hokurd.github.io/road/expwy/${encodeURIComponent(code.toLowerCase())}/`;
            const span = document.createElement('span');
            span.style.display='inline-block';
            span.style.width='3em';
            span.style.color='#ffffff';
            span.style.borderRadius='2px';
            span.style.textAlign='center';
            span.style.padding='5px 0';
            span.style.margin='2px';
            span.style.backgroundColor='#00702c';
            span.textContent = code;
            a.appendChild(span);
            a.appendChild(document.createTextNode(' ' + (name || code)));
            return a;
          } else {
            return createSpan(display);
          }
        }
        if(isPref){
          const bg = PREF_BG[tags['addr:state'] || ''] || sanitizeFileKey(tags['addr:state'] || '') || 'toyamafallback';
          const digits = String(refToken || (name.match(/(\d+)/) || [''])[0] || '');
          const display = (name || ('県道' + digits));
          if(linkify){
            const a = document.createElement('a');
            a.className = 'contact-button';
            a.href = `https://hokurd.github.io/road/pref/${encodeURIComponent(bg)}/${encodeURIComponent(digits)}/`;
            const img = document.createElement('img');
            img.src = `https://hokurd.github.io/assets/img/rd/pref/${encodeURIComponent(bg)}.png`;
            img.alt = '県道背景画像';
            img.className = 'inline-img';
            a.appendChild(img);
            a.appendChild(document.createTextNode(' ' + display));
            return a;
          } else {
            return createSpan(display);
          }
        }
        if(isNat){
          const num = refToken || (name.match(/(\d+)/) || [''])[0] || '';
          const display = (name || ('国道' + num + '号'));
          if(linkify){
            const a = document.createElement('a');
            a.className = 'contact-button';
            a.href = `https://hokurd.github.io/road/gen/${encodeURIComponent(num)}/`;
            const img = document.createElement('img');
            img.src = `https://hokurd.github.io/assets/img/rd/country/${encodeURIComponent(num)}.png`;
            img.alt = '国道画像';
            img.className = 'inline-img';
            a.appendChild(img);
            a.appendChild(document.createTextNode(' ' + display));
            return a;
          } else {
            return createSpan(display);
          }
        }
        return createSpan(name || tags.ref || tags.highway || '道路');
      }
      async function fetchOverpass(q){
        const endpoint = 'https://overpass-api.de/api/interpreter';
        let attempts = 0;
        const maxAttempts = 5;
        while(attempts < maxAttempts){
          let res;
          try{
            res = await fetch(endpoint, { method: 'POST', body: q });
          } catch(e){
            attempts++;
            const delay = Math.min(30000, Math.pow(2, attempts) * 1000);
            await new Promise(r=>setTimeout(r, delay));
            continue;
          }
          if(res.ok){
            try{
              return await res.json();
            } catch(e){
              throw new Error('Overpass parse error');
            }
          }
          if(res.status === 429){
            const ra = res.headers.get('Retry-After');
            let waitMs = ra ? (parseInt(ra,10) * 1000) : (Math.min(30000, Math.pow(2, attempts) * 1000));
            if(isNaN(waitMs) || waitMs <= 0) waitMs = Math.min(30000, Math.pow(2, attempts) * 1000);
            await new Promise(r=>setTimeout(r, waitMs));
            attempts++;
            continue;
          }
          if(res.status >= 500 && res.status < 600){
            attempts++;
            const delay = Math.min(30000, Math.pow(2, attempts) * 1000);
            await new Promise(r=>setTimeout(r, delay));
            continue;
          }
          throw new Error('Overpass error');
        }
        throw new Error('Overpass rate limited');
      }
      function fetchNominatimReverse(lat, lon, zoom=18){
        const emailPart = NOMINATIM_EMAIL ? `&email=${encodeURIComponent(NOMINATIM_EMAIL)}` : '';
        return fetch(`https://nominatim.openstreetmap.org/reverse?lat=${lat}&lon=${lon}&format=json&zoom=${zoom}&accept-language=ja${emailPart}`)
          .then(r => r.ok ? r.json() : null)
          .catch(()=>null);
      }
      function ensureMainMap(lat, lon){
        if(!mainMap){
          mainMap = L.map('map').setView([lat, lon], 15);
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; OpenStreetMap contributors'
          }).addTo(mainMap);
        } else {
          mainMap.setView([lat, lon], mainMap.getZoom() || 15);
        }
        return mainMap;
      }
      function fetchAndDrawFullRouteByRefAdaptive(refToken, highwayCategory, mapContainerId){
        if(!refToken) return Promise.resolve(null);
        if(!lastPos) return Promise.resolve(null);
        const lat = lastPos.coords.latitude, lon = lastPos.coords.longitude;
        let rad = 80000;
        if(highwayCategory === 'motorway') rad = 200000;
        else if(highwayCategory === 'trunk') rad = 150000;
        else if(highwayCategory === 'pref') rad = 80000;
        else rad = 60000;
        let q = `
  [out:json][timeout:50];
  (
    way(around:${rad},${lat},${lon})["ref"~"${refToken}",i];
  );
  out geom;
  `;
        return fetchOverpass(q).then(d=>{
          const ways = (d && d.elements) ? d.elements.filter(e=>e.type==='way' && e.geometry) : [];
          if(ways.length === 0){
            const q2 = `
  [out:json][timeout:50];
  (
    way(around:${rad},${lat},${lon})[name~"${refToken}",i];
  );
  out geom;
  `;
            return fetchOverpass(q2).then(d2=>{
              const ways2 = (d2 && d2.elements) ? d2.elements.filter(e=>e.type==='way' && e.geometry) : [];
              return ways2;
            }).catch(()=>[]);
          }
          return ways;
        }).then(ways=>{
          if(!ways || ways.length === 0) return null;
          const allLatlngs = [];
          ways.forEach(w => {
            const latlngs = w.geometry.map(g=>[g.lat,g.lon]);
            if(latlngs.length) allLatlngs.push(latlngs);
          });
          const el = document.getElementById(mapContainerId);
          if(!el) return {ways, allLatlngs};
          try {
            if(mapContainerId === 'map-motorway'){ if(motorwayMap) { motorwayMap.remove(); motorwayMap = null; } }
            if(mapContainerId === 'map-current-road'){ if(currentRoadMap){ currentRoadMap.remove(); currentRoadMap = null; } }
            if(mapContainerId === 'map-trunk'){ if(trunkMap){ trunkMap.remove(); trunkMap = null; } }
            if(mapContainerId === 'map-pref'){ if(prefMap){ prefMap.remove(); prefMap = null; } }
            const mapRef = L.map(mapContainerId, { attributionControl:false, zoomControl:false });
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution: '&copy; OpenStreetMap contributors' }).addTo(mapRef);
            allLatlngs.forEach(ll => {
              L.polyline(ll, {color:(highwayCategory==='motorway'?'orange':(highwayCategory==='pref'?'green':'blue')), weight:4, opacity:0.9}).addTo(mapRef);
            });
            if(allLatlngs.length){
              const bounds = allLatlngs.reduce((acc, cur) => acc.concat(cur), []);
              mapRef.fitBounds(bounds, {padding:[10,10]});
            } else {
              mapRef.setView([lat, lon], 12);
            }
            if(mapContainerId === 'map-motorway') motorwayMap = mapRef;
            if(mapContainerId === 'map-current-road') currentRoadMap = mapRef;
            if(mapContainerId === 'map-trunk') trunkMap = mapRef;
            if(mapContainerId === 'map-pref') prefMap = mapRef;
          } catch(e){}
          return {ways, allLatlngs};
        }).catch(()=> null);
      }
      function buildIntersectionLabelAndRoads(connectedWays, nearestPoint, nodes){
        const tol = 15;
        for(const n of nodes){
          if(!n.lat || !n.lon) continue;
          const d = distanceMeters(nearestPoint.lat, nearestPoint.lon, n.lat, n.lon);
          if(d <= tol && n.tags && (n.tags.name || n.tags.ref || n.tags['int_name'])){
            const label = (n.tags.name || n.tags['int_name'] || n.tags.ref) + ' の交差点';
            const roads = connectedWays.concat([]);
            return Promise.resolve({label, roads, point:{lat:n.lat, lon:n.lon}});
          }
        }
        return fetchNominatimReverse(nearestPoint.lat, nearestPoint.lon, 18).then(loc => {
          let name = null;
          if(loc){
            name = loc.display_name || (loc.address && (loc.address.road || loc.address.pedestrian || loc.address.cycleway));
          }
          const roads = connectedWays || [];
          if(name){
            return { label: name + ' の交差点', roads, point: nearestPoint };
          }
          const cats = roads.map(w => {
            if(isPrefectureWay(w.tags)) return 'pref';
            if(isNationalWay(w.tags)) return 'national';
            if(isMotorwayWay(w.tags)) return 'motorway';
            return 'other';
          });
          const uniq = Array.from(new Set(cats));
          if(uniq.length === 2 && uniq.includes('pref') && uniq.includes('national')) {
            return { label: '無名の交差点', roads, point: nearestPoint };
          }
          if(uniq.length === 1 && (uniq[0] === 'pref' || uniq[0] === 'national') && cats.filter(x=>x===uniq[0]).length >= 2){
            return { label: '無名の交差点', roads, point: nearestPoint };
          }
          return { label: null, roads, point: nearestPoint };
        }).catch(()=> ({label:null, roads:connectedWays||[], point:nearestPoint}));
      }
      function renderIntersectionSection(obj){
        const container = document.getElementById('next-intersection');
        container.innerHTML = '';
        if(!obj || !obj.point) {
          container.textContent = '交差点名はありません（無名または対象外）';
          if(nextIntersectionMap){ nextIntersectionMap.remove(); nextIntersectionMap = null; }
          return;
        }
        const title = document.createElement('div');
        title.textContent = obj.label || '無名の交差点';
        container.appendChild(title);
        const listDiv = document.createElement('div');
        listDiv.className = 'road-list';
        if(obj.roads && obj.roads.length){
          obj.roads.forEach(w => {
            const tags = w.tags || {};
        
            if ((tags.highway || '').toLowerCase() === 'residential') return;
        
            const el = makeRoadAnchorElement(tags, false);
            if (el) listDiv.appendChild(el);
          });
        } else {
          const p = document.createElement('p');
          p.textContent = '交差している道路の情報はありません。';
          listDiv.appendChild(p);
        }
        container.appendChild(listDiv);
        const elId = 'map-next-intersection';
        if(nextIntersectionMap){ nextIntersectionMap.remove(); nextIntersectionMap = null; }
        try {
          nextIntersectionMap = L.map(elId, { attributionControl:false, zoomControl:false });
          L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution: '&copy; OpenStreetMap contributors' }).addTo(nextIntersectionMap);
          L.marker([obj.point.lat, obj.point.lon]).addTo(nextIntersectionMap).bindPopup(obj.label || '交差点').openPopup();
          const bounds = [[obj.point.lat, obj.point.lon]];
          if(obj.roads && obj.roads.length){
            obj.roads.forEach(w => {
              if(w.geometry){
                const latlngs = w.geometry.map(g=>[g.lat,g.lon]);
                L.polyline(latlngs, {color:'purple', weight:4, opacity:0.8}).addTo(nextIntersectionMap);
                bounds.push(...latlngs);
              }
            });
          }
          nextIntersectionMap.fitBounds(bounds, {padding:[10,10]});
        } catch(e){}
      }
      function shouldPerformUpdate(newPos){
        const now = Date.now();
        if(now - lastUpdateCall < MIN_UPDATE_INTERVAL_MS) return false;
        if(!prevPos) return true;
        const d = distanceMetersSimple(prevPos.coords.latitude, prevPos.coords.longitude, newPos.coords.latitude, newPos.coords.longitude);
        if(d < MIN_MOVE_DISTANCE_M) return false;
        return true;
      }
      function scheduleUpdateIfNeeded(position){
        if(scheduledUpdateTimer){
          clearTimeout(scheduledUpdateTimer);
          scheduledUpdateTimer = null;
        }
        const now = Date.now();
        const since = now - lastUpdateCall;
        if(since >= MIN_UPDATE_INTERVAL_MS){
          lastUpdateCall = now;
          updateNearbyInfo(position.coords.latitude, position.coords.longitude);
        } else {
          const wait = MIN_UPDATE_INTERVAL_MS - since;
          scheduledUpdateTimer = setTimeout(()=>{
            lastUpdateCall = Date.now();
            updateNearbyInfo(position.coords.latitude, position.coords.longitude);
            scheduledUpdateTimer = null;
          }, wait);
        }
      }
      function onPositionUpdate(position){
        prevPos = lastPos;
        lastPos = position;
        if(position.coords && typeof position.coords.heading === 'number' && !isNaN(position.coords.heading)) {
          lastHeading = position.coords.heading;
        } else if(prevPos) {
          const b = bearingBetween(prevPos.coords.latitude, prevPos.coords.longitude, lastPos.coords.latitude, lastPos.coords.longitude);
          lastHeading = b;
        } else {
          lastHeading = null;
        }
        if(shouldPerformUpdate(position)){
          lastUpdateCall = Date.now();
          updateNearbyInfo(position.coords.latitude, position.coords.longitude);
        } else {
          scheduleUpdateIfNeeded(position);
        }
      }
      async function updateNearbyInfo(lat, lon){
        if(overpassInFlight) return;
        overpassInFlight = true;
        try{
          ensureMainMap(lat, lon);
          L.marker([lat, lon]).addTo(mainMap).bindPopup("現在地");
          mainMap.setView([lat, lon], mainMap.getZoom() || 15);
          const radius = 5000;
          const query = `
  [out:json][timeout:25];
  (
    way(around:${radius},${lat},${lon})["highway"~"motorway|trunk|primary|secondary|tertiary|unclassified|residential"];
    node(around:${radius},${lat},${lon})["name"];
    node(around:${radius},${lat},${lon})["highway"~"traffic_signals|stop|crossing|give_way"];
  );
  out geom;
  `;
          const data = await fetchOverpass(query);
          if(!data || !data.elements || data.elements.length===0){
            document.getElementById('current-road').textContent = '近くの道路が見つかりませんでした。';
            overpassInFlight = false;
            return;
          }
          const ways = data.elements.filter(e => e.type === 'way' && e.geometry);
          const nodes = data.elements.filter(e => e.type === 'node' && e.lat && e.lon && e.tags);
          if(ways.length === 0){
            document.getElementById('current-road').textContent = '近くの道路が見つかりませんでした。';
            overpassInFlight = false;
            return;
          }
          let nearestWay = null, nearestPoint = null, minD = Infinity;
          ways.forEach(w => {
            w.geometry.forEach((pt) => {
              const d = distanceMeters(lat, lon, pt.lat, pt.lon);
              if(d < minD){ minD = d; nearestWay = w; nearestPoint = pt; }
            });
          });
          if(!nearestWay){
            document.getElementById('current-road').textContent = '現在走行中の道路を判定できませんでした。';
            overpassInFlight = false;
            return;
          }
          const locdata = await fetchNominatimReverse(lat, lon);
          const pref = (locdata && locdata.address) ? (locdata.address.state || locdata.address.province || '') : '';
          let nearestMotorway = null, minMotorway = Infinity;
          let nearestTrunk = null, minTrunk = Infinity;
          let nearestPref = null, minPref = Infinity;
          ways.forEach(w => {
            w.geometry.forEach(pt => {
              const d = distanceMeters(lat, lon, pt.lat, pt.lon);
              if(isMotorwayWay(w.tags) && d < minMotorway){ minMotorway = d; nearestMotorway = w; }
              if(isPrefectureWay(w.tags) && d < minPref){ minPref = d; nearestPref = w; }
              if(isNationalWay(w.tags) && d < minTrunk){ minTrunk = d; nearestTrunk = w; }
            });
          });
          const fallbackFindPref = () => {
            if(nearestPref) return Promise.resolve(nearestPref);
            const radius2 = 15000;
            const q2 = `
  [out:json][timeout:25];
  way(around:${radius2},${lat},${lon})[name~"県道"];
  out geom;
  `;
            return fetchOverpass(q2).then(d=>{
              if(!d || !d.elements) return null;
              let best=null, bestd=Infinity;
              d.elements.forEach(w=>{
                if(!w.geometry) return;
                w.geometry.forEach(pt=>{
                  const dd = distanceMeters(lat, lon, pt.lat, pt.lon);
                  if(dd < bestd){ bestd = dd; best = w; }
                });
              });
              if(best){ nearestPref = best; minPref = bestd; }
              return nearestPref;
            }).catch(()=>null);
          };
          await fallbackFindPref();
          const currentRoadContainer = document.getElementById('current-road');
          currentRoadContainer.innerHTML = '';
          const title = document.createElement('div');
          title.textContent = '現在走行中: ' + shortRoadLabel(nearestWay.tags || {}) + ` （約 ${Math.round(minD)} m）`;
          currentRoadContainer.appendChild(title);
          const tags = nearestWay.tags || {};
          if ((tags.highway || '').toLowerCase() !== 'residential') {
            const linkable = isMotorwayWay(tags) || isNationalWay(tags) || isPrefectureWay(tags);
            const el = makeRoadAnchorElement(tags, linkable);
            if (el) currentRoadContainer.appendChild(el);
          }
          try {
            const currentLatlngs = nearestWay.geometry.map(g => [g.lat, g.lon]);
            L.polyline(currentLatlngs, {color:'red', weight:6, opacity:0.9}).addTo(mainMap);
            if(nearestPoint){
              L.circleMarker([nearestPoint.lat, nearestPoint.lon], {radius:8, color:'#333', fillColor:'#fff', fillOpacity:0.8}).addTo(mainMap);
            }
          } catch(e){}
          const refToken = pickRefToken(nearestWay.tags && nearestWay.tags.ref ? nearestWay.tags.ref : '');
          if(isMotorwayWay(nearestWay.tags)){
            fetchAndDrawFullRouteByRefAdaptive(refToken || (nearestWay.tags.operator||'').replace(/\s+/g,''), 'motorway', 'map-current-road').catch(()=>{});
          } else if(isNationalWay(nearestWay.tags)){
            fetchAndDrawFullRouteByRefAdaptive(refToken, 'trunk', 'map-current-road').catch(()=>{});
          } else if(isPrefectureWay(nearestWay.tags)){
            fetchAndDrawFullRouteByRefAdaptive(refToken, 'pref', 'map-current-road').catch(()=>{});
          } else {
            if(currentRoadMap){ currentRoadMap.remove(); currentRoadMap = null; }
            try {
              currentRoadMap = L.map('map-current-road', { attributionControl:false, zoomControl:false });
              L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',{ attribution: '&copy; OpenStreetMap contributors' }).addTo(currentRoadMap);
              const latlngs = nearestWay.geometry.map(g=>[g.lat,g.lon]);
              L.polyline(latlngs, {color:'red', weight:5, opacity:0.9}).addTo(currentRoadMap);
              currentRoadMap.fitBounds(latlngs, {padding:[10,10]});
            } catch(e){}
          }
          const tol = 15;
          const connected = ways.filter(e => {
            if(e.id === nearestWay.id) return false;
            return e.geometry && e.geometry.some(g => distanceMeters(g.lat, g.lon, nearestPoint.lat, nearestPoint.lon) <= tol);
          });
          const candidatePoint = nearestPoint;
          const obj = await buildIntersectionLabelAndRoads(connected, candidatePoint, nodes);
          if(obj && (!obj.label) && lastHeading != null){
            const aheadNode = nodes.map(n=>{
              const d = distanceMeters(lat, lon, n.lat, n.lon);
              const brg = bearingBetween(lat, lon, n.lat, n.lon);
              return {...n, dist:d, brg, ahead: angleDiff(brg, lastHeading) <= 90};
            }).filter(n=>n.ahead && n.tags && (n.tags.name||n.tags.ref));
            if(aheadNode && aheadNode.length){
              const n0 = aheadNode.sort((a,b)=>a.dist-b.dist)[0];
              obj.label = (n0.tags.name || n0.tags.ref) + ' の交差点';
              obj.point = {lat:n0.lat, lon:n0.lon};
            }
          }
          renderIntersectionSection(obj);
          if(nearestMotorway){
            const nm = document.getElementById('nearest-motorway'); nm.innerHTML = '';
            const title2 = document.createElement('div');
            title2.textContent = `最も近い高速道路: ${shortRoadLabel(nearestMotorway.tags||{})} （約 ${Math.round(minMotorway)} m）`;
            nm.appendChild(title2);
            nm.appendChild(makeRoadAnchorElement(nearestMotorway.tags||{}, true));
            const mRef = pickRefToken(nearestMotorway.tags && nearestMotorway.tags.ref ? nearestMotorway.tags.ref : (nearestMotorway.tags && nearestMotorway.tags.operator?nearestMotorway.tags.operator.replace(/\s+/g,''): ''));
            fetchAndDrawFullRouteByRefAdaptive(mRef, 'motorway', 'map-motorway').catch(()=>{});
            try {
              const mLatlngs = nearestMotorway.geometry.map(g => [g.lat, g.lon]);
              L.polyline(mLatlngs, {color:'orange', weight:5, dashArray:'6 4', opacity:0.9}).addTo(mainMap);
            } catch(e){}
          } else {
            document.getElementById('nearest-motorway').textContent = '最も近い高速道路は見つかりませんでした。';
            if(motorwayMap){ motorwayMap.remove(); motorwayMap = null; }
          }
          if(nearestTrunk){
            const nt = document.getElementById('nearest-trunk'); nt.innerHTML = '';
            const ttitle = document.createElement('div');
            ttitle.textContent = `最も近い国道: ${shortRoadLabel(nearestTrunk.tags||{})} （約 ${Math.round(minTrunk)} m）`;
            nt.appendChild(ttitle);
            nt.appendChild(makeRoadAnchorElement(nearestTrunk.tags||{}, true));
            const tRef = pickRefToken(nearestTrunk.tags && nearestTrunk.tags.ref ? nearestTrunk.tags.ref : '');
            fetchAndDrawFullRouteByRefAdaptive(tRef, 'trunk', 'map-trunk').catch(()=>{});
            try {
              const tLatlngs = nearestTrunk.geometry.map(g => [g.lat, g.lon]);
              L.polyline(tLatlngs, {color:'blue', weight:5, opacity:0.8}).addTo(mainMap);
            } catch(e){}
          } else {
            document.getElementById('nearest-trunk').textContent = '最も近い国道は見つかりませんでした。';
            if(trunkMap){ trunkMap.remove(); trunkMap = null; }
          }
          if(nearestPref){
            const np = document.getElementById('nearest-pref'); np.innerHTML = '';
            const ptitle = document.createElement('div');
            ptitle.textContent = `最も近い県道: ${shortRoadLabel(nearestPref.tags||{})} （約 ${Math.round(minPref)} m）`;
            np.appendChild(ptitle);
            np.appendChild(makeRoadAnchorElement(nearestPref.tags||{}, true));
            const pRef = pickRefToken(nearestPref.tags && nearestPref.tags.ref ? nearestPref.tags.ref : '');
            fetchAndDrawFullRouteByRefAdaptive(pRef, 'pref', 'map-pref').catch(()=>{});
            try {
              const pLatlngs = nearestPref.geometry.map(g => [g.lat, g.lon]);
              L.polyline(pLatlngs, {color:'green', weight:5, opacity:0.8}).addTo(mainMap);
            } catch(e){}
          } else {
            document.getElementById('nearest-pref').textContent = '最も近い県道は見つかりませんでした。';
            if(prefMap){ prefMap.remove(); prefMap = null; }
          }
          const bounds = [];
          try {
            if(nearestWay.geometry && nearestWay.geometry.length) bounds.push(...nearestWay.geometry.map(g=>[g.lat,g.lon]));
            if(nearestTrunk && nearestTrunk.geometry) bounds.push(...nearestTrunk.geometry.map(g=>[g.lat,g.lon]));
            if(nearestPref && nearestPref.geometry) bounds.push(...nearestPref.geometry.map(g=>[g.lat,g.lon]));
            if(nearestMotorway && nearestMotorway.geometry) bounds.push(...nearestMotorway.geometry.map(g=>[g.lat,g.lon]));
            if(bounds.length){
              try { mainMap.fitBounds(bounds, {padding:[40,40], maxZoom:16}); } catch(e){}
            }
          } catch(e){}
        } catch(err){
          if(err && err.message && err.message.includes('Overpass rate limited')){
            document.getElementById('current-road').textContent = 'Overpass API が混雑しています。しばらくしてから再試行してください。';
          } else {
            console.error(err);
            document.getElementById('current-road').textContent = '道路データの取得に失敗しました。';
          }
        } finally {
          overpassInFlight = false;
        }
      }
      if("geolocation" in navigator){
        const watchId = navigator.geolocation.watchPosition(
          pos => onPositionUpdate(pos),
          err => {
            console.error('geolocation error', err);
            document.getElementById('current-road').innerText = '現在地が取得できませんでした。ブラウザの位置情報許可を確認してください。';
          },
          {enableHighAccuracy: true, maximumAge: 5000, timeout: 15000}
        );
      } else {
        document.getElementById('current-road').innerText = 'このブラウザでは位置情報が利用できません。';
      }
    });
  </script>
  
  <script>
    fetch('https://hokurd.github.io/assets/json/menu.json')
      .then(res => res.json())
      .then(data => {
        const menu = document.getElementById('menu');
        const ul = document.createElement('ul');
        data.forEach(item => {
          const li = document.createElement('li');
          const a = document.createElement('a');
          a.href = item.link;
          a.textContent = item.title;
          li.appendChild(a);
          ul.appendChild(li);
        });
        menu.appendChild(ul);
      });
  </script>
</body>
</html>
